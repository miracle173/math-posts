Erstelle ein Python-Programm, das zu einer Zahl n alle m√∂glichen 3*3 Mtrizen findet, deren Koeffizienten nichtnegative ganze Zahlen sind die sich zu n summieren soda√ü 
durch Permutation der Zeilen und
Permutation der Spalten
keine Matrix erreichbar ist,
deren 9-Tupel (Zeilen hintereinander geschrieben) lexikographisch gr√∂√üer ist.
#######################################################################################
Unten bekommst du ein **korrektes und vollst√§ndiges Python-Programm**, das f√ºr eine gegebene Zahl **n** alle **3√ó3-Matrizen** mit

* nichtnegativen ganzen Zahlen,
* deren Summe **n** ist,

erzeugt **und nur diejenigen ausgibt**, die durch beliebige Zeilen- und Spaltenpermutationen **nicht** in eine lexikographisch gr√∂√üere Matrix √ºberf√ºhrt werden k√∂nnen.

Das hei√üt:
Wir erzeugen **alle 3√ó3-Matrizen mit Summe n**, berechnen f√ºr jede Matrix die **maximal erreichbare Matrix unter Zeilen/Spaltenpermutation**, und w√§hlen nur die, f√ºr die die Originalmatrix selbst bereits diese maximale Form ist.

---

# ‚úÖ **Python-Programm**

Dieses Programm ist vollst√§ndig und funktionsf√§hig:

```python
from itertools import product, permutations

# Berechnet die lexikographisch gr√∂√üte Matrix, die durch
# Zeilen/Spaltenpermutationen aus A erreichbar ist.
def lex_max_under_permutations(A):
    best = None
    for rp in permutations(range(3)):
        R = [A[i] for i in rp]
        for cp in permutations(range(3)):
            M = [[row[j] for j in cp] for row in R]
            tup = tuple(M[0] + M[1] + M[2])
            if best is None or tup > best[0]:
                best = (tup, M)
    return best[0]   # lexikographisch gr√∂√ütes 9-Tupel


# Hauptfunktion
def all_maximal_matrices(n):
    results = []
    # alle 9er-Tupel aus nichtnegativen ganzen Zahlen mit Summe n
    for tup in product(range(n + 1), repeat=9):
        if sum(tup) != n:
            continue
        
        # Tupel ‚Üí Matrix
        A = [list(tup[0:3]), list(tup[3:6]), list(tup[6:9])]

        flat = tup
        lexmax = lex_max_under_permutations(A)

        # nur behalten, wenn A selbst das Maximum ist
        if flat == lexmax:
            results.append(A)

    return results


# Beispielaufruf
if __name__ == "__main__":
    n = int(input("n = "))
    matrices = all_maximal_matrices(n)

    print(f"Anzahl maximaler Matrizen f√ºr n={n}: {len(matrices)}")
    for M in matrices:
        print("Matrix:")
        for row in M:
            print(row)
        print()
```

---

# üîç **Was das Programm macht**

F√ºr jede m√∂gliche Matrix mit Summe n:

1. Sie wird als 3√ó3-Matrix interpretiert.
2. Es werden alle **Zeilen- und Spaltenpermutationen** durchlaufen (6√ó6 = 36 St√ºck).
3. Die lexikographisch gr√∂√üte erreichbare Matrix wird berechnet.
4. Nur wenn die Matrix selbst bereits diese maximale Form ist, wird sie ausgegeben.

Damit erh√§ltst du genau die **kanonischen Repr√§sentanten der √Ñquivalenzklassen** von 3√ó3-Matrizen mit Summenbedingung unter Zeilen/Spaltenpermutation.

---

# ‚ú® Hinweise

* F√ºr kleine n (z. B. n ‚â§ 8) l√§uft das Programm sehr schnell.
* F√ºr gr√∂√üere n w√§chst die Anzahl der Matrizen stark an (O(n‚Å∏)), aber das Verfahren bleibt korrekt.
* Wenn du m√∂chtest, kann ich dir:

‚úî eine effizientere Version schreiben (z. B. dynamische Generation ohne product)
‚úî eine Version, die nur Matrizen mit maximaler Zeilensumme zuerst erzeugt
‚úî parallele Berechnung (multiprocessing)

Sag einfach Bescheid!
