Algorithmus zum Erzeugen aller möglichen Konfigurationen

Algorithmus 1)

    n ist die Anzahl der Clues
    1. Optimiere Box Konfigurationen
    für alle k<=n:
      3x3 Matrix (jedes Element stellt eine Box dar) mit k Einsen belegen (das bedeutet, dass diese Box belegt ist), andere Koefffizienten sind 0
        das sind Comb(9,k) verschiedene Belegunegen, für k=4 bzw. k=5 sind das Comb(9,5)=126 verschiedene Matrizen,für andere k ist Comb(9,k) kleiner
      Wir wollen nun für eine gegebene 3×3-Matrix A diejenige Matrix findet, die durch 
      * Permutation der Zeilen und
      * Permutation der Spalten
      erreichbar ist und
      deren 9-Tupel (Zeilen hintereinander geschrieben) lexikographisch maximal ist. Das geschieht durch ausprobieren aller 3!*3! Kombinationen von Zeilen und Spaltenpermutationen
      2. Für jede dieser k Boxen:
        erzeuge (n(1),...,n(k)) mit 
            Summe(n(j), j=1..k)=n
                unterschiedliche Reihenfolge ergibt verschiedene Tupel
            belege die Boxen, geordnet von links nach rechts und oben nach unten   mit diesen Tupel
            optimiere und filtere wieder lexikographisch wie oben
        3. Nun für jede Box, von links nach rechts, oben nach unten:
            4. für alle a(i) Gruppen von Elemente aus der Box:
                lrtb-maximal
                (left-right-top-bottom-maximal)
                um Maximum zu finden. Nun für alle bisher belegten Boxen gemeinsam
                Box i0,j0 wird  lrtb-maximal
                (left-right-top-bottom-maximal) optimiert,                 alle schon behandelten Boxen müssen nachjustiert werden
                5. für alle restricted growth sequences der Länge n:
                    belege file Zellen in ihrer Reihenfolge mit den Werten
                    wir sudoku-Regel Verletzt, dann ausscheiden
                    liefert Automorphismus Lexikographisch kleinere Folge, dann auscheiden
                
Definition "restricted growth sequence":
1. Die erste Zahl ist immer 1.
2. Jede neue Zahl ist entweder 
    eine Zahl, die bereits früher in der Folge vorkam, oder
    genau um 1 größer als der bisher größte Wert der Folge.

Algoritmus 2)
lrtd-max-stndardize all combinations of n points in a n*n-grid
then put horizontal and vertical box borders in the result
...

Algorithmus:
Gegeben: 
Eine Gruppe G von Abbildungen einer Menge M nach M, die durch die Menge H=M erzeugt wird, also G=<H> und eine Funktion s von M nach R+. s(m) heißt Größe von m.
Gesucht:
Die Menge aller Elemente aus M, die nicht durch eine Abbildung aus G in ein größeres  Element übergeführt werden können, also 
    L := { x | s(x) >= s(g(x)) für alle g aus G}

Natürlich kann L auf folgende Weise Ermittelt werden

    1. A := M
    2. for x in A:

Algorithmus zu, Berechnen der maximalen Elemente:
Gegeben: 
Eine Gruppe G von Abbildungen einer Menge M nach M, die durch die Menge H=M erzeugt wird, also G=<H> und eine Funktion s von M nach R+. s(m) heißt Größe von m.
Gesucht:
Die Menge aller Elemente aus M, die nicht durch eine Abbildung aus G in ein größeres  Element übergeführt werden können, also 
    L := { x | s(x) >= s(g(x)) für alle g aus G}

Natürlich kann L auf folgende Weise ermittelt werden

    L={}
    current_maxvalue=0
    current_maxnodes={}
    for x in M:
        for g in G:
            if s(g(x)) = current_maxvalue:
                current_maxnodes :=
                    current_maxnodes + {x}
            elif s(g(x)) > current_maxvalue:
                current_maxvalue := g(x)
                current_maxnodes := {x}
        L := L + current_maxnodes
        
Der if-elif-Block wird |M|*|G| mal durchlaufen. Das Verfahren kann natürlich verkürzt werden. Sobald man erkennt, das x kein maximales Element ist, wird es ignoriert und das nächste x untersucht. 

    L={}
    for x in M:
        is_maximal := TRUE
        for g in G:
            if s(g(x)) > s(x):
                is_maximal := FALSE
                break
        if is_maximal:
            L := L + {x}

Verbesserung, wenn man M speichern kann

    A := M
    L := {}
    B := {} # Boundary 
    repeat until A  = {}:
        current_maxvalue=0
        current_maxnodes={}
        retrieve and remove x from A
        for g in G:
            y := g(x)
            retrieve and remove y from A
            if s(h(y)) = current_maxvalue:
                current_maxnodes :=
                    current_maxnodes + {x}
            elif s(h(x)) > current_maxvalue:
                current_maxvalue := g(x)
                current_maxnodes := {x}
        L := L + current_maxnodes
 
Verbesserung mit Hilfe des Erzeugendensystems

    A := M
    L := {}
    B := {} # Boundary 
    repeat until A  = {}:
        current_maxvalue=0
        current_maxnodes={}
        retrieve and remove x from A
        B := {x}
        repeat until B = {}:
            retrieve and remove y from B
            for h in H:
                z := h(y)
                if z in A:
                    B := B + {z}
                    remove z from A 
                if s(h(y)) = current_maxvalue:
                    current_maxnodes :=
                        current_maxnodes + {x}
                elif s(h(x)) > current_maxvalue:
                    current_maxvalue := g(x)
                    current_maxnodes := {x}
        L := L + current_maxnodes
                       
Anmerkung; für die Permutationen von n Elementen bildet <(1,2), (1,3), ..., (1,n) ein Erzeugendensystem.
            


            
                
     
  
    
