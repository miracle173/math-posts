Algorithmus zum Erzeugen aller möglichen Konfigurationen

Algorithmus 1)

    n ist die Anzahl der Clues
    1. Optimiere Box Konfigurationen
    für alle k<=n:
      3x3 Matrix (jedes Element stellt eine Box dar) mit k Einsen belegen (das bedeutet, dass diese Box belegt ist), andere Koefffizienten sind 0
        das sind Comb(9,k) verschiedene Belegunegen, für k=4 bzw. k=5 sind das Comb(9,5)=126 verschiedene Matrizen,für andere k ist Comb(9,k) kleiner
      Wir wollen nun für eine gegebene 3×3-Matrix A diejenige Matrix findet, die durch 
      * Permutation der Zeilen und
      * Permutation der Spalten
      erreichbar ist und
      deren 9-Tupel (Zeilen hintereinander geschrieben) lexikographisch maximal ist. Das geschieht durch ausprobieren aller 3!*3! Kombinationen von Zeilen und Spaltenpermutationen
      2. Für jede dieser k Boxen:
        erzeuge (n(1),...,n(k)) mit 
            Summe(n(j), j=1..k)=n
                unterschiedliche Reihenfolge ergibt verschiedene Tupel
            belege die Boxen, geordnet von links nach rechts und oben nach unten   mit diesen Tupel
            optimiere und filtere wieder lexikographisch wie oben
        3. Nun für jede Box, von links nach rechts, oben nach unten:
            4. für alle a(i) Gruppen von Elemente aus der Box:
                lrtb-maximal
                (left-right-top-bottom-maximal)
                um Maximum zu finden. Nun für alle bisher belegten Boxen gemeinsam
                Box i0,j0 wird  lrtb-maximal
                (left-right-top-bottom-maximal) optimiert,                 alle schon behandelten Boxen müssen nachjustiert werden
                5. für alle restricted growth sequences der Länge n:
                    belege file Zellen in ihrer Reihenfolge mit den Werten
                    wir sudoku-Regel Verletzt, dann ausscheiden
                    liefert Automorphismus Lexikographisch kleinere Folge, dann auscheiden
                
Definition "restricted growth sequence":
1. Die erste Zahl ist immer 1.
2. Jede neue Zahl ist entweder 
    eine Zahl, die bereits früher in der Folge vorkam, oder
    genau um 1 größer als der bisher größte Wert der Folge.

Algoritmus 2)
lrtd-max-stndardize all combinations of n points in a n*n-grid
then put horizontal and vertical box borders in the result
...

Algorithmus:
Gegeben: 
Eine Gruppe G von Abbildungen einer Menge M nach M, die durch die Menge H=M erzeugt wird, also G=<H> und eine Funktion s von M nach R+. s(m) heißt Größe von m.
Gesucht:
Die Menge aller Elemente aus M, die nicht durch eine Abbildung aus G in ein größeres  Element übergeführt werden können, also 
    L := { x | s(x) >= s(g(x)) für alle g aus G}

Natürlich kann L auf folgende Weise Ermittelt werden

    1. A := M
    2. for x in A:

Algorithmus zu, Berechnen der maximalen Elemente:
Gegeben: 
Eine Gruppe G von Abbildungen einer Menge M nach M, die durch die Menge H=M erzeugt wird, also G=<H> und eine Funktion s von M nach R+. s(m) heißt Größe von m.
Gesucht:
Die Menge aller Elemente aus M, die nicht durch eine Abbildung aus G in ein größeres  Element übergeführt werden können, also 
    L := { x | s(x) >= s(g(x)) für alle g aus G}

Natürlich kann L auf folgende Weise ermittelt werden

    L={}
    current_maxvalue=0
    current_maxnodes={}
    for x in M:
        for g in G:
            if s(g(x)) = current_maxvalue:
                current_maxnodes :=
                    current_maxnodes + {x}
            elif s(g(x)) > current_maxvalue:
                current_maxvalue := g(x)
                current_maxnodes := {x}
        L := L + current_maxnodes
        
Der if-elif-Block wird |M|*|G| mal durchlaufen. Das Verfahren kann natürlich verkürzt werden. Sobald man erkennt, das x kein maximales Element ist, wird es ignoriert und das nächste x untersucht. 

    L={}
    for x in M:
        is_maximal := TRUE
        for g in G:
            if s(g(x)) > s(x):
                is_maximal := FALSE
                break
        if is_maximal:
            L := L + {x}

Verbesserung, wenn man M speichern kann

    A := M
    L := {}
    B := {} # Boundary 
    repeat until A  = {}:
        current_maxvalue=0
        current_maxnodes={}
        retrieve and remove x from A
        for g in G:
            y := g(x)
            retrieve and remove y from A
            if s(h(y)) = current_maxvalue:
                current_maxnodes :=
                    current_maxnodes + {x}
            elif s(h(x)) > current_maxvalue:
                current_maxvalue := g(x)
                current_maxnodes := {x}
        L := L + current_maxnodes
 
Verbesserung mit Hilfe des Erzeugendensystems

    A := M
    L := {}
    B := {} # Boundary 
    repeat until A  = {}:
        current_maxvalue=0
        current_maxnodes={}
        retrieve and remove x from A
        B := {x}
        repeat until B = {}:
            retrieve and remove y from B
            for h in H:
                z := h(y)
                if z in A:
                    B := B + {z}
                    remove z from A 
                if s(h(y)) = current_maxvalue:
                    current_maxnodes :=
                        current_maxnodes + {x}
                elif s(h(x)) > current_maxvalue:
                    current_maxvalue := g(x)
                    current_maxnodes := {x}
        L := L + current_maxnodes
                       
Anmerkung; für die Permutationen von n Elementen bildet <(1,2), (1,3), ..., (1,n) ein Erzeugendensystem.




####################################################

Optimierung bezüglich der folgenden Ordnung:
S ... Sudoku
pi(S) ??

S = s(i,j; k, l) = Matrix  s(3*i+k, 3*j+l= Folge s(27*i + 9*j +3*k +l)

B(i, j, S):= 0, wenn alle Zellen von Block B_{i,j}des Sudokus S leer sind
             1, sonst
 
N(S) = B{0,0, S) + B(0, 1, S1) + ... + B(2, 1, S1)) + B(2, 2 , S)


B(S):=(B{0,0, S), B(0, 1, S), ..., B(2, 1, S)), B(2, 2 , S)
    
W(i, j, S):= Anzahl der Zellen !=0 im Block B_{i,j} des Sudokus S1
W(S):=  (W{0,0, S), W(0, 1, S), ..., W(2, 1, S)), W(2,2 , 1)


e(x):=  0, wenn x=0
        1, sonst
b(i, j, S) := (e(s(i,j;0,0), e(i, j; 0, 1), ..., e(i, j; 1, 2), e(i, j; 2, 2))
b(S) := (b(0, 0, S), b(0, 1, S), ..., b(2, 1, S), b(2, 2, S)

pi(S, i, j) ist jene Symboltransformation, sodass pi(S) minimal wird,
d.h.  pi(0, 0, S) wird minimiert, danach  pi(0, 1, S), usw.

pi(S) := pi(0, 0, S), pi(0, 1, S), ..., pi(S, 2,1), pi(S, 2, 2))

Ordnung S1<S2:
N(S1) < N(S2) oder
N(S1) = N(S2) und B(S1) < B(S2) oder 
B(S1) = B(S2) und W(S1) < W(S2)
W(S1)=W(S2) und b(S1)=b(S2), oder
b(S1)=b(S2) und pi(S1)<pi(S2), oder
pi(S1)<pi(S2) und S1<S2


              
Beispiel:

    Sudoku 1:        Sudoku 2:
    ..9|...|...      ..1|...|...
    .7.|.9.|...      .2.|.1.|...
    ..4|...|...      ..3|...|...
    ---+---+---      ---+---+---
    ...|...|...      ...|...|...
    ...|...|...      ...|...|...
    ...|...|...      ...|...|...
    ---+---+---      ---+---+---
    ...|...|...      ...|...|...
    ...|...|...      ...|...|...
    ...|...|...      ...|...|...

Sudoku 1 ird durch pi auf Sudoku2 transformiert


Ermittlung des Optimums

Schritt 1) Es wird mittels globaler Operationen das Maximum bezüglich der B-Ordnung ermittelt. Das kann durch ausprobieren aller 2*3!*3! globaler Operationen (Spiegelung, Band-Permutation, Stack-Permutation) geschehen. Möglicherrwiese aber auch durch Optimierung gemäß der Blockordnung.

Schritt 2) Anwendung der Stabilisatoren von 1 zur Ermittlung des Optimums bezüglich der W-Ordnung. 

Anmerkung: Schritt 1 und Schritt2 können in einem Gemeinsamen Schritt durchgeführt werden. Für eine Sortierung von Sudokus müssen allerdings die Ordnungen B und W getrennt betrachtet werden. 

Beispiel:

    Sudoku 1:        Sudoku 2:        Sudoku 3
    1..|1..|1..      12.|1..|...      1..|1..|...
    ...|...|...      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
    ---+---+---      ---+---+---      ---+---+---
    1..|...|1..      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
    ---+---+---      ---+---+---      ---+---+---
    ...|...|...      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
 

Wenn das Sudoku global optimiert ist, dann lokale Optimierung entlang der Blockfolge B(S, 0, 0), B(S, 0 , 1) , ..., B(S, 2, 1), B(S, 2,2). 


Globale Optimierung:
Entweder alle (3!)^2*2=72 Permutationen ausprobieren oder folgender Branch and Bound-Algortihmus



    
    
# Initialisierung
startGrid=self

rowCount=3
colCount=3

currOpt=None
tranposedGrid=deepcopy(startGrid)
tranposedGrid.transpose()
currSolutions=[startGrid, tranposedGrid]
minFreeCol=0
for r in range(rowCount)
    for c range(colCount)
        currOpt=0
        for grid in currSolutions:
            for iin range(maxRows):
                rowIsUsed=False
                for j in range(maxCols):
                    canSwap=(((r==i) 
                        or ((r<i) and not rowIsUsed)) 
                        and ((c==j) or ((minFreeCol==c) and (c<j))))
                    if canSwap and grid(i,j)>=currOpt:
                        gridCopy=deepcopy(grid)
                        rowIsUsed=True
                        assert(c<=minFreeCol)
                        gridCopy.switchRows(i,r)
                        gridCopy.switchCols(j,c)
                        minFreeCol=max(minFreeCol,i)
                        if grid(i,j)>currOpt:
                            nextSolutions=[gridCopy]
                        else:
                            nextSolution.append(gridCopy)
            
            
             
    

"""
    ?=(r,c)
    x=(i,j)
    
    i<r: unmöglich, z.B
    oooooo...      
    oooooo.x.      
    ooooo?...     
    unmöglich     
       
    (case 1)
    r==i, c==j, kein Tausch notwendig
    oooooo...     
    oooooo...     
    oooooyy..      
    .........     
    ok          

    c<minFreeCol
    rowIsUsed=True
    (r,c=!=(i,j)
    oooooo...     
    oooooo...     
    ooooo?.x.      
    ...x.xx..     
    nein          
              
    (case 2)
    i==r, 
    minFreeCol==c<j
    oooooo...         
    oooooo...      
    oooooo?.x        
    .........  
    ok    


    i>r, 
    minFreeCol<=c
    rowIsUsed=True
    oooooo...         
    oooooo...      
    oooooo?..        
    ...x...x.        
    nein          
         
    (case 3)
    r<=i, 
    c==j
    rowIsUsed=False
    oooooo... 
    oooooo... 
    oooooo... 
    ...?.....  
    ...x..... 
    ...x..... 
    ok 

    (case 4)
    r<=i, 
    minFreeCol==c<=j
    rowIsUsed=False
    oooooo... 
    oooooo... 
    oooooo... 
    ......?.x  
    ......x.x 
    ok 
    
    
(r==i and c==j) # case 1
or ((r==i) and (minFreeCol==c<j))#case 2
or (r<i and c==j and not rowIsUsed) #case 3
or (r<=i and minFreeCol==c<=j and not rowIsUsed) #case 4


(r==i and c==j) # case 1
or ((r==i) and (minFreeCol==c<j))#case 2
or (r<i and c==j and not rowIsUsed) #case 3
or (r<i and minFreeCol==c<=j and not rowIsUsed) #case 4

((r==i) and ((c==j) or ((minFreeCol==c) and (c<j))))
or
(r<i) and not rowIsUsed and ((c==j) or ((minFreeCol==c) and (c<=j)))

(((r==i) or ((r<i) and not rowIsUsed)) and ((c==j) or ((minFreeCol==c) and (c<j))))

"""
 

 
            


            
                
     
  
    
