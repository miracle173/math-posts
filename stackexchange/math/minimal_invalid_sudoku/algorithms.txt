Algorithmus zum Erzeugen aller möglichen Konfigurationen

Algorithmus 1)

    n ist die Anzahl der Clues
    1. Optimiere Box Konfigurationen
    für alle k<=n:
      3x3 Matrix (jedes Element stellt eine Box dar) mit k Einsen belegen (das bedeutet, dass diese Box belegt ist), andere Koefffizienten sind 0
        das sind Comb(9,k) verschiedene Belegunegen, für k=4 bzw. k=5 sind das Comb(9,5)=126 verschiedene Matrizen,für andere k ist Comb(9,k) kleiner
      Wir wollen nun für eine gegebene 3×3-Matrix A diejenige Matrix findet, die durch 
      * Permutation der Zeilen und
      * Permutation der Spalten
      erreichbar ist und
      deren 9-Tupel (Zeilen hintereinander geschrieben) lexikographisch maximal ist. Das geschieht durch ausprobieren aller 3!*3! Kombinationen von Zeilen und Spaltenpermutationen
      2. Für jede dieser k Boxen:
        erzeuge (n(1),...,n(k)) mit 
            Summe(n(j), j=1..k)=n
                unterschiedliche Reihenfolge ergibt verschiedene Tupel
            belege die Boxen, geordnet von links nach rechts und oben nach unten   mit diesen Tupel
            optimiere und filtere wieder lexikographisch wie oben
        3. Nun für jede Box, von links nach rechts, oben nach unten:
            4. für alle a(i) Gruppen von Elemente aus der Box:
                lrtb-maximal
                (left-right-top-bottom-maximal)
                um Maximum zu finden. Nun für alle bisher belegten Boxen gemeinsam
                Box i0,j0 wird  lrtb-maximal
                (left-right-top-bottom-maximal) optimiert,                 alle schon behandelten Boxen müssen nachjustiert werden
                5. für alle restricted growth sequences der Länge n:
                    belege file Zellen in ihrer Reihenfolge mit den Werten
                    wir sudoku-Regel Verletzt, dann ausscheiden
                    liefert Automorphismus Lexikographisch kleinere Folge, dann auscheiden
                
Definition "restricted growth sequence":
1. Die erste Zahl ist immer 1.
2. Jede neue Zahl ist entweder 
    eine Zahl, die bereits früher in der Folge vorkam, oder
    genau um 1 größer als der bisher größte Wert der Folge.

Algoritmus 2)
lrtd-max-stndardize all combinations of n points in a n*n-grid
then put horizontal and vertical box borders in the result
...

Algorithmus:
Gegeben: 
Eine Gruppe G von Abbildungen einer Menge M nach M, die durch die Menge H=M erzeugt wird, also G=<H> und eine Funktion s von M nach R+. s(m) heißt Größe von m.
Gesucht:
Die Menge aller Elemente aus M, die nicht durch eine Abbildung aus G in ein größeres  Element übergeführt werden können, also 
    L := { x | s(x) >= s(g(x)) für alle g aus G}

Natürlich kann L auf folgende Weise Ermittelt werden

    1. A := M
    2. for x in A:

Algorithmus zu, Berechnen der maximalen Elemente:
Gegeben: 
Eine Gruppe G von Abbildungen einer Menge M nach M, die durch die Menge H=M erzeugt wird, also G=<H> und eine Funktion s von M nach R+. s(m) heißt Größe von m.
Gesucht:
Die Menge aller Elemente aus M, die nicht durch eine Abbildung aus G in ein größeres  Element übergeführt werden können, also 
    L := { x | s(x) >= s(g(x)) für alle g aus G}

Natürlich kann L auf folgende Weise ermittelt werden

    L={}
    current_maxvalue=0
    current_maxnodes={}
    for x in M:
        for g in G:
            if s(g(x)) = current_maxvalue:
                current_maxnodes :=
                    current_maxnodes + {x}
            elif s(g(x)) > current_maxvalue:
                current_maxvalue := g(x)
                current_maxnodes := {x}
        L := L + current_maxnodes
        
Der if-elif-Block wird |M|*|G| mal durchlaufen. Das Verfahren kann natürlich verkürzt werden. Sobald man erkennt, das x kein maximales Element ist, wird es ignoriert und das nächste x untersucht. 

    L={}
    for x in M:
        is_maximal := TRUE
        for g in G:
            if s(g(x)) > s(x):
                is_maximal := FALSE
                break
        if is_maximal:
            L := L + {x}

Verbesserung, wenn man M speichern kann

    A := M
    L := {}
    B := {} # Boundary 
    repeat until A  = {}:
        current_maxvalue=0
        current_maxnodes={}
        retrieve and remove x from A
        for g in G:
            y := g(x)
            retrieve and remove y from A
            if s(h(y)) = current_maxvalue:
                current_maxnodes :=
                    current_maxnodes + {x}
            elif s(h(x)) > current_maxvalue:
                current_maxvalue := g(x)
                current_maxnodes := {x}
        L := L + current_maxnodes
 
Verbesserung mit Hilfe des Erzeugendensystems

    A := M
    L := {}
    B := {} # Boundary 
    repeat until A  = {}:
        current_maxvalue=0
        current_maxnodes={}
        retrieve and remove x from A
        B := {x}
        repeat until B = {}:
            retrieve and remove y from B
            for h in H:
                z := h(y)
                if z in A:
                    B := B + {z}
                    remove z from A 
                if s(h(y)) = current_maxvalue:
                    current_maxnodes :=
                        current_maxnodes + {x}
                elif s(h(x)) > current_maxvalue:
                    current_maxvalue := g(x)
                    current_maxnodes := {x}
        L := L + current_maxnodes
                       
Anmerkung; für die Permutationen von n Elementen bildet <(1,2), (1,3), ..., (1,n) ein Erzeugendensystem.




####################################################

Optimierung bezüglich der folgenden Ordnung:
S ... Sudoku
pi(S) ??

S = s(i,j; k, l) = Matrix  s(3*i+k, 3*j+l= Folge s(27*i + 9*j +3*k +l)

B(i, j, S):= 0, wenn alle Zellen von Block B_{i,j}des Sudokus S leer sind
             1, sonst
 
N(S) = B{0,0, S) + B(0, 1, S1) + ... + B(2, 1, S1)) + B(2, 2 , S)


B(S):=(B{0,0, S), B(0, 1, S), ..., B(2, 1, S)), B(2, 2 , S)
    
W(i, j, S):= Anzahl der Zellen !=0 im Block B_{i,j} des Sudokus S1
W(S):=  (W{0,0, S), W(0, 1, S), ..., W(2, 1, S)), W(2,2 , 1)


e(x):=  0, wenn x=0
        1, sonst
b(i, j, S) := (e(s(i,j;0,0), e(i, j; 0, 1), ..., e(i, j; 1, 2), e(i, j; 2, 2))
b(S) := (b(0, 0, S), b(0, 1, S), ..., b(2, 1, S), b(2, 2, S)

pi(S, i, j) ist jene Symboltransformation, sodass pi(S) minimal wird,
d.h.  pi(0, 0, S) wird minimiert, danach  pi(0, 1, S), usw.

pi(S) := pi(0, 0, S), pi(0, 1, S), ..., pi(S, 2,1), pi(S, 2, 2))

Ordnung S1<S2:
N(S1) < N(S2) oder
N(S1) = N(S2) und B(S1) < B(S2) oder 
B(S1) = B(S2) und W(S1) < W(S2)
W(S1)=W(S2) und b(S1)=b(S2), oder
b(S1)=b(S2) und pi(S1)<pi(S2), oder
pi(S1)<pi(S2) und S1<S2


              
Beispiel:

    Sudoku 1:        Sudoku 2:
    ..9|...|...      ..1|...|...
    .7.|.9.|...      .2.|.1.|...
    ..4|...|...      ..3|...|...
    ---+---+---      ---+---+---
    ...|...|...      ...|...|...
    ...|...|...      ...|...|...
    ...|...|...      ...|...|...
    ---+---+---      ---+---+---
    ...|...|...      ...|...|...
    ...|...|...      ...|...|...
    ...|...|...      ...|...|...

Sudoku 1 ird durch pi auf Sudoku2 transformiert


Ermittlung des Optimums

Schritt 1) Es wird mittels globaler Operationen das Maximum bezüglich der B-Ordnung ermittelt. Das kann durch ausprobieren aller 2*3!*3! globaler Operationen (Spiegelung, Band-Permutation, Stack-Permutation) geschehen. Möglicherrwiese aber auch durch Optimierung gemäß der Blockordnung.

Schritt 2) Anwendung der Stabilisatoren von 1 zur Ermittlung des Optimums bezüglich der W-Ordnung. 

Anmerkung: Schritt 1 und Schritt2 können in einem Gemeinsamen Schritt durchgeführt werden. Für eine Sortierung von Sudokus müssen allerdings die Ordnungen B und W getrennt betrachtet werden. 

Beispiel:

    Sudoku 1:        Sudoku 2:        Sudoku 3
    1..|1..|1..      12.|1..|...      1..|1..|...
    ...|...|...      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
    ---+---+---      ---+---+---      ---+---+---
    1..|...|1..      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
    ---+---+---      ---+---+---      ---+---+---
    ...|...|...      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
    ...|...|...      ...|...|...      ...|...|...
 

Wenn das Sudoku global optimiert ist, dann lokale Optimierung entlang der Blockfolge B(S, 0, 0), B(S, 0 , 1) , ..., B(S, 2, 1), B(S, 2,2). 


Globale Optimierung:
Entweder alle (3!)^2*2=72 Permutationen ausprobieren oder folgender Branch and Bound-Algortihmus



    
    
# Initialisierung
startGrid=self

rowCount=3
colCount=3

currOpt=None
tranposedGrid=deepcopy(startGrid)
tranposedGrid.transpose()
currSolutions=[startGrid, tranposedGrid]
minFreeCol=0
for r in range(rowCount)
    for c range(colCount)
        currOpt=0
        for grid in currSolutions:
            for iin range(maxRows):
                rowIsUsed=False
                for j in range(maxCols):
                    canSwap=(((r==i) 
                        or ((r<i) and not rowIsUsed)) 
                        and ((c==j) or ((minFreeCol==c) and (c<j))))
                    if canSwap and grid(i,j)>=currOpt:
                        gridCopy=deepcopy(grid)
                        rowIsUsed=True
                        assert(c<=minFreeCol)
                        gridCopy.switchRows(i,r)
                        gridCopy.switchCols(j,c)
                        minFreeCol=max(minFreeCol,i)
                        if grid(i,j)>currOpt:
                            nextSolutions=[gridCopy]
                        else:
                            nextSolution.append(gridCopy)
            
            
             
    

"""
    ?=(r,c)
    x=(i,j)
    
    i<r: unmöglich, z.B
    oooooo...      
    oooooo.x.      
    ooooo?...     
    unmöglich     
       
    (case 1)
    r==i, c==j, kein Tausch notwendig
    oooooo...     
    oooooo...     
    oooooyy..      
    .........     
    ok          

    c<minFreeCol
    rowIsUsed=True
    (r,c=!=(i,j)
    oooooo...     
    oooooo...     
    ooooo?.x.      
    ...x.xx..     
    nein          
              
    (case 2)
    i==r, 
    minFreeCol==c<j
    oooooo...         
    oooooo...      
    oooooo?.x        
    .........  
    ok    


    i>r, 
    minFreeCol<=c
    rowIsUsed=True
    oooooo...         
    oooooo...      
    oooooo?..        
    ...x...x.        
    nein          
         
    (case 3)
    r<=i, 
    c==j
    rowIsUsed=False
    oooooo... 
    oooooo... 
    oooooo... 
    ...?.....  
    ...x..... 
    ...x..... 
    ok 

    (case 4)
    r<=i, 
    minFreeCol==c<=j
    rowIsUsed=False
    oooooo... 
    oooooo... 
    oooooo... 
    ......?.x  
    ......x.x 
    ok 
    
    
(r==i and c==j) # case 1
or ((r==i) and (minFreeCol==c<j))#case 2
or (r<i and c==j and not rowIsUsed) #case 3
or (r<=i and minFreeCol==c<=j and not rowIsUsed) #case 4


(r==i and c==j) # case 1
or ((r==i) and (minFreeCol==c<j))#case 2
or (r<i and c==j and not rowIsUsed) #case 3
or (r<i and minFreeCol==c<=j and not rowIsUsed) #case 4

((r==i) and ((c==j) or ((minFreeCol==c) and (c<j))))
or
(r<i) and not rowIsUsed and ((c==j) or ((minFreeCol==c) and (c<=j)))

(((r==i) or ((r<i) and not rowIsUsed)) and ((c==j) or ((minFreeCol==c) and (c<j))))

"""
 

 
            
lokale Optimierung

Block(0,0) bis (Block( (r,c)-1) schon optimiert

alle Stabilisatoren der Block 0,0 bis (r,c)-1 anwenden,
wenn der Block (r,c) der erste der Reihe it, alsoc=0 oder c>0 aber der Block davor in niedrigerer  Reihe,
dann Zeilenoptimierung anwendxen

Blocksize (r,c)

B_{r,c} = 

Block= next block

optimiere Block unter Berücksichtigung der Blöcke oberhalb und links von ihm, d. h. 
minimiere den Block mittels der Stabilisatoren der bisherigen Blocksequenz

aus der Menge der Stabilisatoren ermittel alle Stabilisatoren des neuen Blocks, eliminiere alle Stabilisatoren, die sich nicht auf Stabilisatoren des neuen Blocks erweitern lassen. sind Zeilen bzw Spalten durch diesen Neuen Block zum Band dazugekommen, dann sind die Permutationen dieser Splaten und Zeilen mit den alten Stabilisatoren zu combinieren und zu testen, also teste, ob 
    stab_alt*rowperm_neu*colperm_neu
ein Stabilisatoer für den neuen Block ist. Wenn ja, dann ist diese Kombination ein Stabilisatore der gesamten bisherigen Blockfolge, wenn nein, dann nicht. So lassen sich alle Stabilisatoren fineden

man beachte, dass 
    stab_alt*rowperm_neu*colperm_neu
kommutativ ist

Bound: 
für jeden globalen Stabilisatore:
wende den globalen Stabilisator auf die Kette an. 

Suche nun die längste gemeinsame globale Kette des der ursprünglichen Kette und ihres Bildes
Optimiere die neue ketee loakl. Ist sie größer als die ursprüngliche Kette, dann kann die ursprüngliche Kette nicht mehr maximal werden und die lokale Optimierung der ursprünglichen Kette kann abgebrochen werden.

Bound lohnt sich vermutlich nicht, deshalb erst wenn man die komplette kette lokal optimiert, jeden globalen Stabilisator anwenden und Ergebnis jeweils lokal optimieren

Stabilisatorengrid SG: 
SG representiert die Blöcke der SegmentedMateix, also eine 3*3 Matrix
der Wert ist entweder eine eine Liste von Zeilenpermutation-Spaltenpermutation-Paaren oder ein Vermerk, dass alle Permutationspaare erlaubt sind, wir nehmen dazu das die leere Liste

Lokale Optimierung:
Initialisierung:
S[i][j]=[] for i in range(bandDim), for j in (stackDim)

G ist die die Matrix der globalen Werte, G ist ebenfalls eine bandDim*stackDim-Matrix

Optimierung einer konkreten SegmentedMatrix:

Schneller Algorithmus:

# create a list myCurrSolutions of all images of the global stabilizers
# set a mark for all copies of the duplicate of the original matrix
# this is needed to check later, if the original matrix isn't a maximum
myCurrSolutions=[]
for myBlockPermutation in myStartMatrix.globalStabilisators:
    myCopyMatrix= deepcopy of myStartMatrix
    apply myBlockPermutation to myCopyMatrix
    myCurrSolutions.append(myCopyMatrix)  
    if myCopyMatrix==myStartMatrix:
        myCopyMatrix.isOriginal=True


# create a list myNextSolutions that does not contain duplicates
# for this sort the items and if two consecutive items are the same, 
# remove one of them
myCurrSolutions.sort()
myNextSolutions=[]
for mySolution in myCurrSolutions:
    if myNextSolutions:
        if myNextSolutions[-1]!=mySolution:
            myNextSolutions.append(mySolution)
    else:
        myNextSolution=[mySolution]
        

        
# for all blocks optimize the block without changing the preceding blocks 
# that were already optimized
# the order of the blocks is B00, B01, B02, B10, B11, B12, B20, B21, B22

# there is a bandDim*stackDim matrix globalBlockValues that contains the global block values of this
# SegmentedMatrix, that was used for global optimization
# this matrix does not change during the execution of the algorithm
# there is a bandDim*stackDim matrix localStabs that will be modified during the execution 
# of the algorithm  but is the same for all matrices during a step


# AllPerms is a constant that represents all row-permutation/column-permutation combinations 

localStabs=[[AllPerms for s in range(self.stackDim)] for b in range(self.bandDim)]
eaqch SegmentedMatrix contains its bandDim*stackDim matrix of height/width pair for each block 

for b in range(self.bandDim):
    for s in range(self.stackDim):
        localStabs[b][s]=AllPerms
        if globalBlockValue[b][s] is empty:
            # block[b][s].localStabs bleibt weiterhin leer
            continue
        for mySegmentedMatrix in currSolutions:
            if i==0:
                myLeftBlockRowPerms=all row permutations
                myLeftBlockHeight=0
            else:
                myLeftBlockRowPerms=row permutations of block[b-1][s].localStabs
                myLeftBlockHeight=mySegmentedMatrix.block[b-1][s].height
            if j==0:
                myUpperBlockColPerms=all column permutations
                myUpperBlockWidth=0
            else:
                myUpperBlockColPerms=column permutations of block[b][s-1].localStabs
                myUpperBlockWidth=mySegmentedMatrix.block[b][s-1].width
            
            myContentHeight=height(globVal[b][s])
            myContentWidth=width(globVal[b][s]) 
            myBlock[b][s].height=min(myLeftBlockHeight+myContentHeight, maxBlockHeight)
            myBlock[b][s].width=min(myUpperBlockWidth+myContentWidth, maxBlockWidth)
            
            myFreeRowPerms=augment idendity permutation of 1..(myLeftBlockHeight-1) 
                by permutations of myLeftBlockHeight..(myBlock[b][s].height-1) for band b
            myFreeColPerms=augment idendity permutation of 1..(myUpperBlockWidth-1) 
                by permutations of myUpperBlockWidth..(myBlock[b][s].width-1) for stack s
            
            # now optimize for all Stabilisators
            
            for myRowStab in myLeftBlockRowPerms:
                for myColStab in myUpperBlockColPerms:
                    for myOtherRowPerm in myFreeRowPerms:
                        for myOtherColPerm in myFreeColPerms:
                            perm=myRowStab*myColStab*myOtherRowPerm*myOtherColPerm
                            apply perm to Block b,s of mySegmentedMatrix
                                and calculate value of this block as myBlockValue
                            if myBlockValue >= myCurrentOptimum:
                                myCopyMatrix = deepcopy of mySegmentedMatrix
                                apply perm to myBlockValue
                                
                                if myBlockValue > currOpt:
                                    currOpt=myBlockValue
                                    nextSolutions=[myCopyMatrix]
                                elif this value == currOpt:
                                    nextSolutions.append(myCopyMatrix)
                                    
            # now optimal Block is found, find the stabilizers for this block 
            #  that are consistent to the previous processed blocks
            myBlockStabilizers=[]
            myTestBlock=Block b,s of one matrix of nextSolutions
            for myRowStab in set of row permutations in myLeftBlockRowPerms:
                for myColStabs in set of col permutations in myUpperBlockColPerms:
                    for myOtherRowPerms in myFreeRowPerms:
                        for myOtherColPerms in myFreeColPerms:
                            perm=myRowStab*mycolStabs*myOtherRowPerms*myOtherColPerms
                            myCopyBlock=copy of myTestBlock
                            apply perm to myCopyBlock 
                            if myCopyBlock is sill equal to myTestBlock:
                                myBlockStabilizers.append(perm)
            now eliminate all stabilizers from the other blocks that now missing in the myBlockStabilizers
                also the dependent ons
            
        currSolutions=nextSolutions

result: currSollutions        
                                

= removing the stabilizers

which row-permutation/column-permutation must be removed from Block b,s, because they are not stabilizers

# initialize
myRemoveRowPermutation=[set() for _ in range(self.bandDim)
myRemoveColPermutation=[set() for _ in range(self.stackDim)

# find out which row permutations and column permuation must be skipped
myOldRowPerms =myLeftBlockRowPerms
myOldColPerms = myUpperBlockColPerms

myNewRowPerms=set()
myNewColPerms=set()
myStabilizers
for myRowPerm in myOldRowPerms:
    for myColPerm in myOldColPerms:
        if myRowPerm*myColPerm is Stabilizer of Submatrix b,s:
            myStabilizers.append(myRowPerm*myColPerm)
            myNewRowPerms.add(myRowPerm)
            myNewColPerms.add(myColPerms)


myRemoveRowPermutation[b].update(myOldRowPerms-myNewRowPerms)
myRemoveColPermutation[s].update(myOldColPerms-myNewColPerms)


def removeItems(aItems, aComponentsToRemove):
    myRowComponentsToRemove, myColComponentsToRemove= aComponentsToRemove
    myOldRowComponents=set()
    myOldColComponents=set()
    myNewRowComponents=set()
    myNewColComponents=set()
    myKeptItems=set()
    for myItem in aItems:
        myRowComponent, myColComponent = myItem
        myOldRowComponents.add(myRowComponent)
        myOldColComponents.add(myColComponent)
        if myRowComponent in myRowComponentsToRemove or myColComponent in myColComponentsToRemove:
            continue
        myNewRowComponents.add(myRowComponent)
        myNewColComponents.add(myColComponent)
        myKeptItems.append(myItem)
    myNewRowComponentsToRemove=(myOldRowComponents-myNewRowComponents)-myRowComponentsToRemove
    myNewColComponentsToRemove=(myOldColComponents-myNewColComponents)-myColComponentsToRemove
    myNewComponentsToRemove=(myNewRowComponentsToRemove, myNewColComponentsToRemove)
    return(myKeptItems, myNewComponentsToRemove)   

def cleanupGrid(aGrid, aPosition, aRemoveList):
    # modifies aGrid !!!
    myRowDim=len(aGrid)
    myColDim=len(aGrid[0])
    myRow,myCol=aPosition
    myControlGrid=[[set() for _ in range(colDim)] in range(colDim)]
    myControlGrid[myRow][myCol]=aRemoveList
    myGridIsClean=False
    while not myGridIsClean:
        myGridIsClean=True
        for i in range(myRowDim):
            for j in range(myColDim)):
                if myControlGrid[i][j]:
                    (myKeptItems, (myRowComponentes, myColComponents))=removeItems(aGrid[i][j], myControlGrid[i][j])
                    aGrid[i][j]=myKeptItems
                    if myRowComponentes:
                        myGridIsClean=False
                        for k in range(myRowDim):
                            if k!=i:
                                myControlGrid[k][j]|=myRowComponentes
                    if myColComponents:
                        myGridIsClean=False
                        for k in range(myColDim)):
                                if k!=j:
                                    myControlGrid[i][k]|=myColComponents

                    
                    
= simple Optimierung eines 3*3 Grids

1. reduktion:
    alle leeren Bänder nach Rechts
    alle leeren Stacks nach unten
    bei allen nichtleeren Bändern:
        alle Zeilen innerhalb des Bandes nach rechts
    bei allen Nichtleeren Stacks:
        alle leeren Spalten innerhalb des Stacks nach links
        
    für jedes Band bestimme den Index der größten Zeile = Anzahl der Zeilen, die nicht 0 sind

            
            




                                
                    
= vollständige Optimierung einer Konfiguration:

In zwei Schritten

1. globale Optimierung durchführen
2. alle Stabilizer auf dieses optimum anwenden
3. alle diese Lösungen lokal optimieren, die größte behalten


= Erzeugen aller Konfigurationen

1. Alle globalen Maxma erzeugen indem man alle Blockmatrizen durchscannt und nur die Maxima übriglässt
2. Das Stufe für Stufe durchführen durch anwenden aller Stabilisatoren
2. Für jedes Blockmaximum für jeden Block alle Varianten erzeugen

= Beispiel

4 Clues, 3 Blöcke

1. mit drei Blöcken gibt es folgende vier Varianten. Diese Bekommt man, wenn man alle COmbinaion(9,3) blöcke des Sudokus durchtestet

ooo

oo.
o.

oo.
..o

o..
.o.
..o

2. Wählen wir 

oo.
o.

Diese besitzt zwei Stabilizer: die Idendität und die Transposition

da gibt es mit 4 Clues nur die Möglichkeit, dass ein Blcok 2 Clues und die beiden anderen einen Clue enthalten

also
11
2.

12
1.

21
1.

Die erste und zweite Variante können mittels Transposition, dem Stabilizer, ineinander übergeführt werden.

wir scheiden deshalb die erste Variante aus.

Bei 2 Clues in einem Feld gibt es im wesentlichen diese zwei Anordnungsmöglichkeiten

oo
..

o.
.o

Diesen sind die Zahlen 1+2 (=3) und 1+16 (=17) zugeordnet
Alle anderen können durch Spalten-, Zeilentausch bzw Spiegelung auf diese zurückgeführt werden

Wir entscheiden uns für 3 und müssen deshalb für den Block folgende 18 Varianten betrachten

oo 

3 Varianten pro Zeile, sind 9 Vrianten


o
o
3 Varianten pro Spalte, sind 9 Vrianten


Alle anderen Varianten können wir ignorieren, da sie nicht minimal sind. Daraus könnne folgende Varianten konstruiert werden, alle anderen sind sicher nicht minimal

Block 00 und Block 01
o|oo
-+--

o|..
.|oo
-+--

                       
o|o
.|o
-+-

o|.
.|o
.|o
-+-

Block 00 und Block 10
o|
-+
o|

o.|
--+
.o|

Das ergibt 8 Möglichkeiten













height(Block):=min(height(Band)+height(Blockmembers),maxHeight)
width(Block):=min(width(Stack)+width(Blockmembers), maxWidth)
    Vereinfachung: height(Blockmembers)=width(Blockmembers)=count(Blockmembers)
    height(Band)= height(Block links) oder 0, falls dieser nicht existiert
    width(Stack)= width(Block oberhalb) oder 0, falls dieser nicht existiert


Beispiel:
221
100
000

1 |11|1
 1|  | 
--+--+-
1 |  |
--+--+-

in shortcuts:
\-*
*00
000

B_00 =h(\)*w(\)=2*2
    B_01:
    h(B_00)+h(-)=2+1=3
    w(-)=2
B_01=3*2    
    B_02:
    h(B_01)+h(*)=2+1=4
    w(*)=1
B_02=3*1
B_10=3*1
B_11=leer
B_12=leerB:03=...=leer

B_00:
    stab:
        r()c()
        r(01)c(01)
        
B_01: 











    



            
                
     
  
    
